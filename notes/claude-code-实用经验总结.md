# Claude Code 实用经验总结

> 总结日期：2025-12-27
> 基于今日研究的 Superpowers 和 Skills.deeptoai.com 文档

---

## 目录

- [核心理念](#核心理念)
- [开发方法论](#开发方法论)
- [实用技巧](#实用技巧)
- [工具选择](#工具选择)
- [最佳实践](#最佳实践)
- [常见陷阱](#常见陷阱)

---

## 核心理念

### 1. 渐进式披露（Progressive Disclosure）

**原理**：只在需要时提供信息，而不是一次性给出所有上下文。

**优势**：
- 💰 节省 90% 的 token 消耗
- ⚡ 提高响应速度
- 🎯 更精准的控制
- 🔄 更容易调试和优化

**实践方式**：
```
❌ 错误做法：一次性加载整个项目
Claude: "请分析这个 10 万行代码的项目"

✅ 正确做法：按需提供信息
Claude: "我需要实现用户认证功能"
→ 系统只在需要时加载认证相关文件
→ 完成后清理上下文
```

**关键工具**：
- **Claude Skills**: 内置渐进式披露机制
- **MCP Servers**: 按需提供数据访问
- **Subagents**: 独立工作，保持主对话简洁

### 2. 系统化 > 随意

**核心理念**：建立系统化的工作流程，而不是依赖临时决策。

**对比**：

| 方面 | 随意方式 | 系统化方式 |
|------|----------|------------|
| Bug 修复 | 直接改代码 | 4 阶段调试流程 |
| 功能开发 | 直接开始写 | brainstorm → plan → execute |
| 代码质量 | 希望没 bug | TDD 强制测试 |
| 协作 | 口头约定 | 标准化流程 |

**系统化框架**（来自 Superpowers）：
```
1. Brainstorming（头脑风暴）
   └→ 明确需求，探索方案

2. Planning（规划）
   └→ 详细计划，任务分解

3. Git Worktrees（隔离环境）
   └→ 安全的并行开发

4. TDD（测试驱动开发）
   └→ RED → GREEN → REFACTOR

5. Code Review（代码审查）
   └→ 质量检查，知识传递

6. Finishing（完成）
   └→ 验证、合并、清理
```

### 3. 证据 > 声明

**核心原则**：不要说"它应该工作了"，要证明它确实工作了。

**验证层级**：
```
Level 1: "代码看起来没问题"
   ↓
Level 2: "测试通过了"
   ↓
Level 3: "在真实环境中验证了"
   ↓
Level 4: "有自动化测试防止回归"
   ↓
Level 5: "有监控和告警机制"
```

**实践工具**：
- **TDD**: 测试先行，证明功能正确
- **Verification-before-completion**: 完成前必须验证
- **Defense-in-depth**: 多层验证机制
- **自动化测试**: 持续验证系统状态

---

## 开发方法论

### 1. 测试驱动开发（TDD）

**严格流程**：
```
RED 阶段
  1. 编写一个失败的测试
  2. 运行测试，确认它失败（重要！）
  3. 理解测试要验证什么

GREEN 阶段
  4. 编写最简单的代码让测试通过
  5. 运行测试，确认它通过
  6. 不要在这个阶段写完美代码

REFACTOR 阶段
  7. 在测试保护下改进代码
  8. 运行测试，确保仍然通过
  9. 提交代码

⚠️ 关键规则：
- 如果在测试之前写了代码，删除它！
- 一次只写一个测试
- 保持测试简单和独立
```

**工具支持**：
- Superpowers 的 `test-driven-development` 技能
- 会自动删除在测试之前编写的代码
- 强制执行 RED-GREEN-REFACTOR 循环

### 2. 系统化调试（4 阶段）

**阶段 1：问题识别**
```
✅ 明确定义错误
✅ 收集证据（日志、堆栈跟踪）
✅ 一致地重现问题
✅ 确定确切的失败点
```

**阶段 2：假设形成**
```
✅ 基于数据列出可能原因
✅ 不要跳到结论
✅ 记录所有假设
✅ 按概率排序
```

**阶段 3：假设测试**
```
✅ 设计实验验证每个假设
✅ 一次只测试一个假设
✅ 记录测试结果
✅ 用证据排除或确认假设
```

**阶段 4：解决方案实施**
```
✅ 修复根因（不是症状）
✅ 添加测试防止回归
✅ 验证修复有效
✅ 文档化解决方案
```

**实际案例**：
```python
# 问题：API 返回 500 错误

# 阶段 1：收集证据
- 检查日志：数据库连接超时
- 重现错误：100% 可重现
- 确定位置：用户查询函数

# 阶段 2：形成假设
1. 数据库服务器宕机？
2. 查询太慢？
3. 连接池耗尽？
4. 网络问题？

# 阶段 3：测试假设
- 测试 1：数据库正常（✓ 排除）
- 测试 2：查询耗时 50ms（✓ 排除）
- 测试 3：连接池已满（✗ 确认！）
- 测试 4：不需要继续

# 阶段 4：实施解决方案
- 修复：增加连接池大小
- 测试：添加连接池监控
- 验证：压力测试通过
- 文档：更新配置说明
```

### 3. 子代理驱动开发

**核心思想**：为每个任务启动独立的子代理，而不是让一个代理做所有事情。

**优势**：
- 🚀 **并行处理**：多个任务同时进行
- 🎯 **专注性**：每个代理专注一个任务
- 🔄 **隔离性**：失败不影响其他任务
- 📊 **可追踪**：清晰的任务历史

**两阶段审查**：
```
任务分配 → 子代理执行
              ↓
    第一阶段审查：规范合规性
    - 是否符合计划要求？
    - 是否完成所有任务？
    - 是否遵循最佳实践？
              ↓
         通过/不通过
              ↓
    第二阶段审查：代码质量
    - 代码是否清晰？
    - 是否有测试？
    - 性能是否可接受？
              ↓
         完成/返工
```

**实际应用**：
```python
# 任务：实现用户认证系统

# 传统方式：一个代理做所有事
Agent: "实现 OAuth2 认证"
→ 生成大量代码
→ 容易迷失方向
→ 难以审查

# 子代理方式：分解任务
Plan:
  1. [Subagent 1] 设置 OAuth2 配置 (5分钟)
  2. [Subagent 2] 创建认证控制器 (10分钟)
  3. [Subagent 3] 实现 token 存储 (8分钟)
  4. [Subagent 4] 添加错误处理 (7分钟)
  5. [Subagent 5] 编写集成测试 (12分钟)

每个子代理：
- 接收明确的任务
- 独立完成工作
- 提交成果
- 主代理审查
```

---

## 实用技巧

### 1. 头脑风暴技巧（苏格拉底式方法）

**目标**：通过提问引导出真正的需求，而不是假设需求。

**提问技巧**：

```bash
# ❌ 错误方式：假设需求
"我需要实现用户登录"
→ 直接开始编码
→ 可能实现错误的功能

# ✅ 正确方式：探索需求
"我需要实现用户登录"

Claude 会问：
1. "需要哪些登录方式？（密码/社交/SSO）"
2. "是否需要记住登录状态？"
3. "如何处理登录失败？"
4. "是否有安全合规要求？"
5. "预期的用户量级？"
6. "是否需要多因素认证？"

→ 明确真实需求
→ 探索多种方案
→ 发现潜在问题
→ 做出明智决策
```

**实践流程**：
```
1. 提出初步想法
   ↓
2. Claude 问澄清性问题
   ↓
3. 你回答问题
   ↓
4. Claude 探索替代方案
   ↓
5. 讨论权衡和限制
   ↓
6. 达成设计共识
   ↓
7. 分块展示设计文档
   ↓
8. 验证和批准
```

### 2. Git Worktree 魔法

**问题**：多人协作时，如何安全地并行开发多个功能？

**传统方式的问题**：
```bash
# 开发者 A：功能 A
git checkout -b feature-a
# 修改代码...
# 还没完成，需要切换到功能 B

git checkout feature-b  # ❌ 冲突！需要 stash 或 commit
```

**Git Worktree 解决方案**：
```bash
# 创建多个并行工作目录
git worktree add ../project-feature-a feature-a
git worktree add ../project-feature-b feature-b
git worktree add ../project-bugfix bugfix-123

# 现在有三个独立的工作目录
/project-main       # 主分支
/project-feature-a  # 功能 A
/project-feature-b  # 功能 B
/project-bugfix     # Bug 修复

# 每个目录完全独立，可以：
- 同时在不同分支工作
- 不会互相干扰
- 不需要 stash
- 真正的并行开发
```

**Superpowers 集成**：
```
/superpowers:using-git-worktrees

自动：
1. 创建新的 worktree
2. 创建功能分支
3. 运行项目设置
4. 验证测试基线
5. 开始开发

完成后：
1. 验证所有测试
2. 提交更改
3. 推送到远程
4. 清理 worktree
```

### 3. 自动化文档生成

**核心理念**：不要手动写文档，用 AI 自动生成。

**工作流程**：
```
1. 开发 Skill
   ↓
2. skill-article-writer 分析 Skill
   - 分析 SKILL.md
   - 研究代码示例
   - 提取关键概念
   ↓
3. 生成技术文档
   - 7,000+ 字的深度分析
   - 包含代码示例
   - 多语言版本（EN/ZH/FR）
   ↓
4. skill-article-publisher 验证
   - MDX 语法检查
   - 构建验证
   - 自动修复常见问题
   ↓
5. 自动发布
   - 语义化提交
   - 推送到仓库
   - 自动部署
```

**关键工具**：
- **skill-article-writer**: 智能内容生成
- **skill-article-publisher**: 质量保证和发布
- **MDX 验证**: 自动语法检查
- **构建验证**: npm run build

---

## 工具选择

### 决策矩阵：Skills vs MCP vs Subagents

**何时使用 Claude Skills？**

✅ **使用场景**：
- 工作流程自动化（如 TDD 流程）
- 复杂的多步骤任务
- 需要渐进式披露
- 团队标准化流程
- 重复性开发任务

❌ **不适用**：
- 简单的一次性任务
- 需要大量自定义逻辑
- 实时性要求极高
- 超低延迟需求

**何时使用 MCP Servers？**

✅ **使用场景**：
- 数据访问（数据库、API）
- 文件系统操作
- 外部工具集成
- 需要持久连接
- 跨会话状态管理

❌ **不适用**：
- 纯粹的逻辑控制
- 简单的数据转换
- 不需要外部资源的任务

**何时使用 Subagents？**

✅ **使用场景**：
- 并行任务处理
- 独立的功能开发
- 需要隔离的任务
- 大型任务分解

❌ **不适用**：
- 简单任务（开销太大）
- 需要频繁同步
- 共享状态复杂

### 实用决策树

```
需要访问外部资源？
├─ 是 → 使用 MCP Server
└─ 否 → 继续

需要复杂多步骤流程？
├─ 是 → 继续
└─ 否 → 直接对话即可

流程需要标准化和复用？
├─ 是 → 使用 Claude Skill
└─ 否 → 使用 Subagent

任务可以并行分解？
├─ 是 → 使用多个 Subagent
└─ 否 → 单个 Subagent 即可
```

---

## 最佳实践

### 1. 开发流程

**推荐的完整流程**：

```
1. 需求探索
   /superpowers:brainstorm "功能描述"
   → 明确需求
   → 探索方案
   → 达成共识

2. 创建隔离环境
   /superpowers:using-git-worktrees
   → 新分支
   → Clean slate
   → 避免冲突

3. 详细规划
   /superpowers:write-plan "实现目标"
   → 任务分解
   → 依赖分析
   → 时间估算

4. 执行实现
   /superpowers:execute-plan
   → 自动应用 TDD
   → 子代理驱动
   → 持续审查

5. 代码审查
   /superpowers:requesting-code-review
   → 质量检查
   → 知识传递
   → 改进建议

6. 完成整合
   /superpowers:finishing-a-development-branch
   → 验证测试
   → 合并/PR
   → 清理环境
```

### 2. 质量保证

**多层质量门**：

```
Level 1: TDD
   └→ 每个功能都有测试
   └→ 测试先于实现

Level 2: Code Review
   └→ 每个任务都审查
   └→ 两个阶段（规范+质量）

Level 3: Verification
   └→ 完成前验证
   └→ 回归测试

Level 4: Defense in Depth
   └→ 多层验证
   └→ 监控和告警
```

### 3. 团队协作

**标准化流程**：

```
✅ 全员使用相同的工作流程
✅ 统一的代码审查标准
✅ Git worktree 并行开发
✅ 文档自动生成和更新
✅ 知识库共享
```

**知识管理**：

```
1. Skills 作为培训材料
   └→ 新人快速上手
   └→ 最佳实践文档化

2. 代码审查作为知识传递
   └→ 不仅仅是找问题
   └→ 分享经验和技巧

3. 自动化文档
   └→ 项目文档自动生成
   └→ 始终保持最新
```

---

## 常见陷阱

### 1. 过度设计

```
❌ 错误：小项目用重型流程
项目：简单的 To-Do 列表
做法：完整 Superpowers 工作流程
结果：浪费时间，得不偿失

✅ 正确：根据项目规模调整
小项目：直接对话 + 基本 TDD
中项目：部分 Superpowers 技能
大项目：完整工作流程
```

### 2. 忽略学习曲线

```
❌ 错误：期望立即精通
"今天安装 Superpowers，明天就要熟练使用"

✅ 正确：循序渐进学习
Week 1: 学习核心命令（brainstorm, write-plan, execute-plan）
Week 2: 掌握 TDD 和 systematic-debugging
Week 3: 学习协作技能（code review, git worktree）
Week 4: 高级功能（subagent, 自定义技能）
```

### 3. 强制推行

```
❌ 错误：管理层强制推行
"从明天开始，所有人必须使用 Superpowers"

✅ 正确：试点推广
1. 小团队试点
2. 收集反馈
3. 调整流程
4. 逐步推广
5. 持续改进
```

### 4. 忽视文化

```
❌ 错误：工具优先
"买了工具，问题就解决了"

✅ 正确：文化先行
1. 建立质量第一的文化
2. 培养系统化思维
3. 鼓励知识分享
4. 然后引入工具
```

---

## 快速参考

### 核心命令速查

```bash
# Superpowers 核心三命令
/superpowers:brainstorm "功能描述"
/superpowers:write-plan "实现目标"
/superpowers:execute-plan

# 开发流程
/superpowers:using-git-worktrees          # 创建隔离环境
/superpowers:test-driven-development     # TDD 流程
/superpowers:systematic-debugging        # 系统化调试
/superpowers:finishing-a-development-branch  # 完成分支

# 代码审查
/superpowers:requesting-code-review      # 请求审查
/superpowers:receiving-code-review       # 接收反馈

# 高级功能
/superpowers:subagent-driven-development # 子代理驱动
/superpowers:writing-skills              # 创建自定义技能
```

### 工作流程速查

```
简单任务：
直接对话 → 编写代码 → 手动测试

中等任务：
brainstorm → write-plan → execute-plan

复杂任务：
brainstorm → git-worktree → write-plan
→ execute-plan (with TDD) → code-review
→ finishing-branch

团队协作：
标准化流程 + git-worktree + code-review
+ 自动化文档 + 知识库
```

---

## 总结

### 核心价值

1. **渐进式披露**：节省 token，提高效率
2. **系统化方法**：减少错误，提高质量
3. **测试驱动**：保证质量，防止回归
4. **子代理驱动**：并行处理，提高速度
5. **自动化流程**：减少重复，专注创新

### 实施建议

**个人开发者**：
1. 从 TDD 开始
2. 学习系统化调试
3. 掌握三个核心命令
4. 逐步增加技能

**开发团队**：
1. 小范围试点
2. 建立标准化流程
3. 培训和知识分享
4. 持续改进优化

**组织层面**：
1. 文化先行
2. 工具支撑
3. 质量优先
4. 长期投入

---

**相关文档**：
- `docs/principles/superpowers-深度解析.md`
- `notes/superpowers-研究总结.md`
- `resources/skills-deeptoai-docs/README.md`

**维护者**: Claude Code Research Team
**最后更新**: 2025-12-27
